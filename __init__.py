bl_info = {
    "name": "Aperture JSON tracking import",
    "author": "Christian F. (known as Chryfi)",
    "version": (1, 5, 6),
    "blender": (2, 80, 0),
    "location": "File > Import",
    "description": "Import tracking data from a json file generated by the Aperture Mod.",
    "warning": "",
    "category": "Import"
}
version_no = 156

import bpy
import json
import math
from math import sqrt
import traceback

from mathutils import Euler, Matrix, Vector
from bpy.props import (BoolProperty, IntProperty, StringProperty)
from bpy_extras.io_utils import (ImportHelper, path_reference_mode)

class ImportJSON(bpy.types.Operator, ImportHelper):
    """Load an Aperture tracking data file"""
    bl_idname = "import_scene.trackjson"
    bl_label = 'Import Aperture JSON'
    bl_options = {'PRESET'}

    # Panel's properties
    filename_ext = ".json"
    filter_glob = StringProperty(default="*.json", options={'HIDDEN'})
    use_selection = BoolProperty(name="Selection only", description="Import selected json only", default=False)
    path_mode = path_reference_mode
    check_extension = True
    frameOffsetPanel: IntProperty(name="Frame offset", default=1)
    cameraImport: BoolProperty(name="Import Camera", default=True)
    entityImport: BoolProperty(name="Import Entities", default=True)
    morphImport: BoolProperty(name="Import Morph-trackers", default=True)
    eulerFilterButton: BoolProperty(name="Use Discontinuity (Euler) Filter", default=True)
    deltaLocationX: IntProperty(name="Delta Location X", default=0)
    deltaLocationY: IntProperty(name="Delta Location Y", default=0)
    deltaLocationZ: IntProperty(name="Delta Location Z", default=0)

    def execute(self, context):
        file = open(self.properties.filepath,)
        data = json.load(file)
        obj_camera = bpy.context.scene.camera
        frameOffset = self.properties.frameOffsetPanel
        ignoreFrame = -1
        dynamicFOV = True
        positionOffsetX = 0 #seems as if the x coordinate needs to be 0.05 off???
        positionOffsetY = 0
        positionOffsetZ = 0
        cameraIndex = "camera_tracking"
        entityIndex = "entity_tracking"
        morphIndex = "morph_tracking"

        if obj_camera is None:
            self.report({"WARNING"}, "No active camera found in the scene.")
            file.close()
            return {"CANCELLED"}

        try:
            if "information" in data:
                try:
                    renderInfo = data["information"]
                    bpy.context.scene.render.fps = renderInfo["fps"]
                    bpy.context.scene.render.resolution_x = renderInfo["resolution"][0]
                    bpy.context.scene.render.resolution_y = renderInfo["resolution"][1]
                    ignoreFrame = round(renderInfo["motionblur_fps"]) / bpy.context.scene.render.fps

                    if renderInfo["motionblur_fps"] != renderInfo["fps"]: #motionblur equivalent settings to ffmpeg's motionblur
                        bpy.context.scene.eevee.motion_blur_position = 'END'
                        bpy.context.scene.eevee.motion_blur_shutter = 1
                        bpy.context.scene.cycles.motion_blur_position = 'END'
                        bpy.context.scene.render.motion_blur_shutter = 1

                    dynamicFOV = renderInfo["dynamic_fov"]

                    if version_no<renderInfo["required_import_version"]:
                        self.report({"WARNING"}, "The version of the import script is not compatible with the data! Update the script at https://github.com/Chryfi/io_import_aperture_tracking/releases")
                        file.close()
                        return {"CANCELLED"}
                except:
                    print("Something went wrong while reading the information data!")
                    traceback.print_exc()

            obj_camera.delta_location = (positionOffsetX, positionOffsetY, positionOffsetZ)
            obj_camera.rotation_mode = 'XYZ'
            obj_camera.data.sensor_fit = 'VERTICAL'

            #camera tracking
            if self.properties.cameraImport is True:

                #iterate through frames of camera
                for frame in range(len(data[cameraIndex])):
                    igFrame = ignoreFrameTest(ignoreFrame, frame)

                    if igFrame == "continue": 
                        continue 
                    else: 
                        blenderFrame = igFrame

                    frameData = data[cameraIndex][frame]
                    keyframePos = blenderFrame+frameOffset
            
                    obj_camera.delta_location = (self.properties.deltaLocationX, self.properties.deltaLocationY, self.properties.deltaLocationZ)
                    obj_camera.location = (frameData["position"][0], -frameData["position"][2], frameData["position"][1])
                    obj_camera.delta_rotation_euler  = Euler((math.radians(90-frameData["angle"][3]), 0, math.radians(-frameData["angle"][2]-180)), 'XYZ')
                    obj_camera.rotation_euler = Euler((0, 0, -math.radians(frameData["angle"][1])), 'XYZ')

                    #NyanLi https://github.com/NyaNLI helped a lot to figure out how to convert Minecraft FOV to Blender's FOV
                    fovFactor = 1.1 if dynamicFOV else 1 #fov*1.1 because of specator mode and dynamic fov - ignores whether other fov effects take place

                    obj_camera.data.lens =  0.5/(math.tan(fovFactor*math.radians(frameData["angle"][0])/2)) * obj_camera.data.sensor_height

                    insertLocation(obj_camera, keyframePos)
                    insertRotationEuler(obj_camera, keyframePos)
                    obj_camera.keyframe_insert(data_path="delta_rotation_euler", frame=keyframePos)
                    obj_camera.data.keyframe_insert(data_path="lens", frame=keyframePos)

                bpy.context.view_layer.objects.active.select_set(False)
                bpy.context.view_layer.objects.active = obj_camera
                obj_camera.select_set(True)
                self.eulerFilter()

            #entity tracking
            if entityIndex in data and self.properties.entityImport is True:
                entities = data[entityIndex]
                keyset = entities.keys()

                #iterate through entities
                for entityKey in keyset:
                    entity = entities[entityKey]

                    obj = addArmature(entityKey)

                    #iterate through frames of entity
                    for frame in range(len(entity)):
                        igFrame = ignoreFrameTest(ignoreFrame, frame)

                        if igFrame == "continue": 
                            continue 
                        else: 
                            blenderFrame = igFrame

                        frameData = entity[frame]
                        keyframePos = blenderFrame+frameOffset

                        if "body_rotation" in frameData:
                            obj.delta_rotation_euler  = Euler((math.radians(90-frameData["body_rotation"][2]), 0, math.radians(-frameData["body_rotation"][1])), 'XYZ')
                            obj.keyframe_insert(data_path="delta_rotation_euler", frame=keyframePos)
                        
                        obj.delta_location = (self.properties.deltaLocationX, self.properties.deltaLocationY, self.properties.deltaLocationZ)
                        obj.location = (frameData["position"][0], -frameData["position"][2], frameData["position"][1])
                        insertLocation(obj, keyframePos)

                    self.eulerFilter()
            

            #morph tracking
            if self.properties.morphImport is True:
                morphs = data[morphIndex]
                keyset = morphs.keys()

                #iterate through morphs
                for morphKey in keyset:
                    morph = morphs[morphKey]

                    obj = addArmature(morphKey)
                    
                    startFrame = 0

                    #iterate through frames of morph
                    for frame in range(len(morph)):
                        igFrame = ignoreFrameTest(ignoreFrame, frame)

                        if igFrame == "continue": 
                            continue 
                        else: 
                            blenderFrame = igFrame
                        
                        frameData = morph[frame]

                        if frame == 0:
                            startFrame = int(int(frameData["frame"]) // ignoreFrame)

                        keyframePos = blenderFrame+frameOffset+startFrame

                        rotmatrixdata = frameData["rotation"]
                        delta_rotation = Euler((math.radians(90), 0, 0), 'XYZ').to_matrix().to_4x4()
                        
                        rotation_matrix = Matrix((
                        Vector((rotmatrixdata[0][0], rotmatrixdata[1][0], rotmatrixdata[2][0], 0)),
                        Vector((rotmatrixdata[0][1], rotmatrixdata[1][1], rotmatrixdata[2][1], 0)),
                        Vector((rotmatrixdata[0][2], rotmatrixdata[1][2], rotmatrixdata[2][2], 0)),
                        Vector((0, 0, 0, 1))))
                        
                        rotation_matrix = delta_rotation @ rotation_matrix
                        
                        translation_matrix = Matrix((
                        Vector((1, 0, 0, frameData["position"][0])),
                        Vector((0, 1, 0,-frameData["position"][2])),
                        Vector((0, 0, 1, frameData["position"][1])),
                        Vector((0, 0, 0, 1))))
                        
                        scale_matrix = Matrix((
                        Vector((frameData["scale"][0], 0, 0, 0)),
                        Vector((0, frameData["scale"][1], 0, 0)),
                        Vector((0, 0, frameData["scale"][2], 0)),
                        Vector((0, 0, 0, 1))))

                        obj.matrix_world = translation_matrix @ rotation_matrix @ scale_matrix
                        obj.delta_location = (self.properties.deltaLocationX, self.properties.deltaLocationY, self.properties.deltaLocationZ)

                        insertLocRotScale(obj, keyframePos)

                    self.eulerFilter()
        
        except:
            traceback.print_exc()
            self.report({"WARNING"}, "An error occured while reading the file.")
            file.close()
            return {"CANCELLED"}
        
        file.close()
        return{'FINISHED'}

    def draw(self, context):
        layout = self.layout
        layout.use_property_split = True
        layout.use_property_decorate = False

        sfile = context.space_data
        operator = sfile.active_operator

        layout.prop(operator, 'frameOffsetPanel')
        layout.prop(operator, 'cameraImport')
        layout.prop(operator, 'entityImport')
        layout.prop(operator, 'morphImport')
        layout.prop(operator, 'eulerFilterButton')
        layout.prop(operator, 'deltaLocationX')
        layout.prop(operator, 'deltaLocationY')
        layout.prop(operator, 'deltaLocationZ')

    def eulerFilter(self):
        if self.properties.eulerFilterButton is True:
            screen = bpy.context.window.screen
            for area in screen.areas:
                if area.type != 'TOPBAR':
                    oldtype = area.type
                    area.type = 'GRAPH_EDITOR'
                    override = {'window': bpy.context.window, 'screen': screen, 'area': area}
                    bpy.ops.graph.euler_filter(override)
                    area.type = oldtype
                    break

def ignoreFrameMath(ignoreFrame : int, frame : int):
    if int(frame)%int(ignoreFrame) != 0:
        return "continue"
    return int(int(frame) // ignoreFrame)

def ignoreFrameTest(ignoreFrame : int, frame : int):
    if ignoreFrame != -1:
        igFrame = ignoreFrameMath(ignoreFrame, frame)

        return igFrame

    return frame


# Register and stuff
def menu_func_import(self, context):
    self.layout.operator(ImportJSON.bl_idname, text="JSON trackingdata (.json)")

classes = (
    ImportJSON, 
)

def addArmature(name):
    bpy.ops.object.armature_add()

    obj = bpy.context.active_object
    obj.name = name

    return obj

def insertLocation(obj, framePos):
    obj.keyframe_insert(data_path="location", frame=framePos)

def insertRotationEuler(obj, framePos):
    obj.keyframe_insert(data_path="rotation_euler", frame=framePos)

def insertScale(obj, framePos):
    obj.keyframe_insert(data_path="scale", frame=framePos)

def insertLocRotScale(obj, framePos):
    insertRotationEuler(obj, framePos)
    insertLocation(obj, framePos)
    insertScale(obj, framePos)

def register():
    from bpy.utils import register_class
    for cls in classes:
        register_class(cls)

    bpy.types.TOPBAR_MT_file_import.append(menu_func_import)

def unregister():
    from bpy.utils import unregister_class
    for cls in reversed(classes):
        unregister_class(cls)

    bpy.types.TOPBAR_MT_file_import.remove(menu_func_import)
