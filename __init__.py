bl_info = {
    "name": "Aperture JSON cameradata import",
    "author": "Christian F. (known as Chryfi)",
    "version": (0, 8, 0),
    "blender": (2, 80, 0),
    "location": "File > Import",
    "description": "Import camera movement from a json file generated by the aperture mod.",
    "warning": "",
    "category": "Import"
}

import bpy
import json
import math
import traceback
import sys
import os
import numpy

_modules_path = os.path.join(os.path.dirname(__file__), "modules")
if not _modules_path in sys.path:
    sys.path.append(_modules_path)
del _modules_path

from . import interpolation
from mathutils import Euler
from bpy.props import (BoolProperty, StringProperty)
from bpy_extras.io_utils import (ImportHelper, path_reference_mode)



class ImportJSON(bpy.types.Operator, ImportHelper):
    # Panel's information
    bl_idname = "test.open_filbrowser"
    bl_label = 'Import Aperture JSON'
    bl_options = {'PRESET'}

    # Panel's properties
    filename_ext = ".json"
    filter_glob = StringProperty(default="*.json", options={'HIDDEN'})
    use_selection = BoolProperty(name="Selection only", description="Import selected json only", default=False)
    path_mode = path_reference_mode
    check_extension = True

    def execute(self, context):
        file = open(self.properties.filepath,)
        data = json.load(file)
        obj_camera = bpy.context.scene.camera
        frameOffset = 2 #first frame of minema rendered video are not usable.
        coordinateCorrectionY = 0 #seems as if the y coordinate needs to be -0.04 off

        if obj_camera is None:
            self.report({"WARNING"}, "No active camera found in the scene.")
            file.close()
            return {"CANCELLED"}

        try:
            if "information" in data:
                renderInfo = data["information"]
                bpy.context.scene.render.fps = renderInfo["fps"]
                bpy.context.scene.render.resolution_x = renderInfo["resolution"][0]
                bpy.context.scene.render.resolution_y = renderInfo["resolution"][1]
                
                if renderInfo["held_frames"] > 1:
                    frameOffset = 1
            
            obj_camera.delta_location = (0, coordinateCorrectionY, 0)

            #possible interpolated functions for FOV dataset https://docs.google.com/spreadsheets/d/1WJVoWsvNT1AA2BxMRuZtXw0CxF1kkeuByHMhyBgvIy8/edit?usp=sharing
            # 0.302458 + 1.99536 x - 0.00622598 x^2
            x_points = [   140,     130,  120,  110,  100,  90,    80,   70,   60,    50,    40,    30,    20,    10,     5, 2.5]
            #y_points = [ 2.325,  3.3825, 4.44, 5.65, 7.02, 8.5, 10.35, 12.5, 15.3, 19.05, 24.55, 33.55, 50.65, 102.4, 205.2, 411] old points
            y_points = [ 2.325,  3.3825, 4.44, 5.65, 7.02, 8.5, 10.35, 12.5, 15.3, 19.05, 25.1051, 33.55, 50.65, 102.4, 205.2, 411] #determined while shooting a movie

            #tck = interpolate.splrep(x_points, y_points)

            for frame in range(len(data["camera-tracking"])):
                frameData = data["camera-tracking"][frame]
            
                obj_camera.location = (frameData["position"][0], -frameData["position"][2], frameData["position"][1])
                obj_camera.delta_rotation_euler  = Euler((math.radians(90-frameData["angle"][3]), 0, math.radians(-frameData["angle"][2]-180)), 'XYZ')
                obj_camera.rotation_euler = Euler((0, 0, -math.radians(frameData["angle"][1])), 'XYZ')
                #blenderFOV = convertMinecraftFOV(frameData["angle"][0])
                #obj_camera.data.lens = 0.5*obj_camera.data.sensor_width*(1/math.tan(0.5*math.radians(blenderFOV)))
                #obj_camera.data.lens = interpolate.splev(frameData["angle"][0], tck)
                #obj_camera.data.lens = interpolation.cubic_interpolation([frameData["angle"][0]], x_points, y_points)
                obj_camera.data.lens = numpy.interp(frameData["angle"][0], x_points, y_points)

                obj_camera.keyframe_insert(data_path="location", frame=frame+frameOffset)
                obj_camera.keyframe_insert(data_path="delta_rotation_euler", frame=frame+frameOffset)
                obj_camera.keyframe_insert(data_path="rotation_euler", frame=frame+frameOffset)
                obj_camera.data.keyframe_insert(data_path="lens", frame=frame+frameOffset)

            if "entities" in data:
                entities = data["entities"]
                keyset = entities.keys()

                for entityKey in keyset:
                    entity = entities[entityKey]
                    bpy.ops.object.armature_add()
                    obj = bpy.context.active_object
                
                    obj.name = entityKey

                    for frame in range(len(entity)):
                        frameData = entity[frame]

                        if "body_rotation" in frameData:
                            obj.delta_rotation_euler  = Euler((math.radians(90-frameData["body_rotation"][2]), 0, math.radians(-frameData["body_rotation"][1])), 'XYZ')
                            obj.keyframe_insert(data_path="delta_rotation_euler", frame=frame+frameOffset)

                        obj.location = (frameData["position"][0], -frameData["position"][2], frameData["position"][1])
                        obj.keyframe_insert(data_path="location", frame=frame+frameOffset)

        except:
            traceback.print_exc()
            self.report({"WARNING"}, "An error occured while reading the file.")
            file.close()
            return {"CANCELLED"}
        
        file.close()
        return{'FINISHED'}

# Register and stuff
def menu_func_export(self, context):
    self.layout.operator(ImportJSON.bl_idname, text="JSON cameradata (.json)")

classes = (
    ImportJSON, 
)

def register():
    from bpy.utils import register_class
    for cls in classes:
        register_class(cls)

    bpy.types.TOPBAR_MT_file_import.append(menu_func_export)

def unregister():
    from bpy.utils import unregister_class
    for cls in reversed(classes):
        unregister_class(cls)

    bpy.types.TOPBAR_MT_file_import.remove(menu_func_export)

"""def convertMinecraftFOVinterpolation(x):
    x_points = [   140,     130,  120,  110,  100,  90,    80,   70,   60,    50,    40,    30,    20,    10,     5, 2.5]
    y_points = [ 2.325,  3.3825, 4.44, 5.65, 7.02, 8.5, 10.35, 12.5, 15.3, 19.05, 24.55, 33.55, 50.65, 102.4, 205.2, 411]

    tck = interpolate.splrep(x_points, y_points)
    return interpolate.splev(x, tck)"""
