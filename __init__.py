bl_info = {
    "name": "Aperture JSON cameradata import",
    "author": "Christian F. (known as Chryfi)",
    "version": (1, 1, 0),
    "blender": (2, 80, 0),
    "location": "File > Import",
    "description": "Import camera movement from a json file generated by the aperture mod.",
    "warning": "",
    "category": "Import"
}

import bpy
import json
import math
from math import sqrt
import traceback
import sys
import os
import numpy

from mathutils import Euler
from bpy.props import (BoolProperty, StringProperty)
from bpy_extras.io_utils import (ImportHelper, path_reference_mode)

def cubic_interp(x0, x, y):
    """
    Interpolate a 1-D function using cubic splines.
      x0 : a 1d-array of floats to interpolate at
      x : a 1-D array of floats sorted in increasing order
      y : A 1-D array of floats. The length of y along the
          interpolation axis must be equal to the length of x.

    Implement a trick to generate at first step the cholesky matrice L of
    the tridiagonal matrice A (thus L is a bidiagonal matrice that
    can be solved in two distinct loops).

    additional ref: www.math.uh.edu/~jingqiu/math4364/spline.pdf 
    # original function code at: https://stackoverflow.com/a/48085583/36061
    
    
    This function is licenced under: Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)
    https://creativecommons.org/licenses/by-sa/3.0/
    Original Author raphael valentin
    Date 3 Jan 2018
    
    
    Modifications made to remove numpy dependencies:
        -all sub-functions by MR
        
    This function, and all sub-functions, are licenced under: Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)        
        
    Mod author: Matthew Rowles
    Date 3 May 2021
    
    """
    def diff(lst):
        """
        numpy.diff with default settings
        """
        size = len(lst)-1
        r = [0]*size
        for i in range(size):
            r[i] = lst[i+1] - lst[i] 
        return r
    
    def list_searchsorted(listToInsert, insertInto):
        """
        numpy.searchsorted with default settings
        """
        def float_searchsorted(floatToInsert, insertInto):
            for i in range(len(insertInto)):
                if floatToInsert <= insertInto[i]:
                    return i
            return len(insertInto)
        return [float_searchsorted(i, insertInto) for i in listToInsert]
    
    def clip(lst, min_val, max_val, inPlace = False):    
        """
        numpy.clip
        """
        if not inPlace:
            lst = lst[:]  
        for i in range(len(lst)):
            if lst[i] < min_val:
                lst[i] = min_val
            elif lst[i] > max_val:
                lst[i] = max_val  
        return lst
    
    def subtract(a,b):
        """
        returns a - b
        """
        return a - b
    
    size = len(x)

    xdiff = diff(x)
    ydiff = diff(y)

    # allocate buffer matrices
    Li   = [0]*size
    Li_1 = [0]*(size-1)
    z    = [0]*(size)

    # fill diagonals Li and Li-1 and solve [L][y] = [B]
    Li[0]   = sqrt(2*xdiff[0])
    Li_1[0] = 0.0
    B0      = 0.0 # natural boundary
    z[0]    = B0 / Li[0]

    for i in range(1, size-1, 1):
        Li_1[i] = xdiff[i-1] / Li[i-1]
        Li[i] = sqrt(2*(xdiff[i-1]+xdiff[i]) - Li_1[i-1] * Li_1[i-1])
        Bi = 6*(ydiff[i]/xdiff[i] - ydiff[i-1]/xdiff[i-1])
        z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]

    i = size - 1
    Li_1[i-1] = xdiff[-1] / Li[i-1]
    Li[i]     = sqrt(2*xdiff[-1] - Li_1[i-1] * Li_1[i-1])
    Bi        = 0.0 # natural boundary
    z[i]      = (Bi - Li_1[i-1]*z[i-1])/Li[i]

    # solve [L.T][x] = [y]
    i = size-1
    z[i] = z[i] / Li[i]
    for i in range(size-2, -1, -1):
        z[i] = (z[i] - Li_1[i-1]*z[i+1])/Li[i]

    # find index
    index = list_searchsorted(x0,x)
    index = clip(index, 1, size-1)

    xi1 = [x[num]   for num in index]
    xi0 = [x[num-1] for num in index]
    yi1 = [y[num]   for num in index]
    yi0 = [y[num-1] for num in index]
    zi1 = [z[num]   for num in index]
    zi0 = [z[num-1] for num in index]
    hi1 = list( map(subtract, xi1, xi0) )

    # calculate cubic - all element-wise multiplication
    f0 = [0]*len(hi1)
    for j in range(len(f0)):
        f0[j] = zi0[j]/(6*hi1[j])*(xi1[j]-x0[j])**3 + \
                zi1[j]/(6*hi1[j])*(x0[j]-xi0[j])**3 + \
                (yi1[j]/hi1[j] - zi1[j]*hi1[j]/6)*(x0[j]-xi0[j]) + \
                (yi0[j]/hi1[j] - zi0[j]*hi1[j]/6)*(xi1[j]-x0[j])        
    
    return f0

class ImportJSON(bpy.types.Operator, ImportHelper):
    # Panel's information
    bl_idname = "test.open_filbrowser"
    bl_label = 'Import Aperture JSON'
    bl_options = {'PRESET'}

    # Panel's properties
    filename_ext = ".json"
    filter_glob = StringProperty(default="*.json", options={'HIDDEN'})
    use_selection = BoolProperty(name="Selection only", description="Import selected json only", default=False)
    path_mode = path_reference_mode
    check_extension = True

    def execute(self, context):
        file = open(self.properties.filepath,)
        data = json.load(file)
        obj_camera = bpy.context.scene.camera
        frameOffset = 1 #first frame of minema rendered video are not usable.
        ignoreFrame = -1
        coordinateCorrectionX = 0 #seems as if the x coordinate needs to be 0.05 off

        if obj_camera is None:
            self.report({"WARNING"}, "No active camera found in the scene.")
            file.close()
            return {"CANCELLED"}

        try:
            if "information" in data:
                renderInfo = data["information"]
                bpy.context.scene.render.fps = renderInfo["fps"]
                bpy.context.scene.render.resolution_x = renderInfo["resolution"][0]
                bpy.context.scene.render.resolution_y = renderInfo["resolution"][1]
                ignoreFrame = round(renderInfo["motionblur_fps"]) / bpy.context.scene.render.fps 
                
                if renderInfo["held_frames"] > 1:
                    frameOffset = 1
            
            obj_camera.delta_location = (0, coordinateCorrectionX, 0)

            #interpolation data
            #x_points = [ 2.5,  2.81,  3.125,   3.75,   5,   6.25,    7.5,     10,  12.5,  15,    20,   25,    30,  35,    40,     50,    60,    70,     80,   90,  100,  110,    120,  130,  140]
            #y_points = [ 422, 375.5, 337.75, 281.25, 211, 168.75, 140.63, 105.25,  84.1,  70, 52.15, 41.4, 34.25,  29, 25.13, 19.525, 15.63, 12.75, 10.525, 8.68, 7.125, 5.71, 4.535, 3.41, 2.35]

            obj_camera.rotation_mode = 'XYZ'
            obj_camera.data.sensor_fit = 'VERTICAL'

            for frame in range(len(data["camera-tracking"])):
                
                blenderFrame = frame

                if ignoreFrame != -1:
                    if int(frame)%int(ignoreFrame) != 0:
                        continue
                    blenderFrame = int(int(frame) // ignoreFrame)

                frameData = data["camera-tracking"][frame]
            
                obj_camera.location = (frameData["position"][0], -frameData["position"][2], frameData["position"][1])
                obj_camera.delta_rotation_euler  = Euler((math.radians(90-frameData["angle"][3]), 0, math.radians(-frameData["angle"][2]-180)), 'XYZ')
                obj_camera.rotation_euler = Euler((0, 0, -math.radians(frameData["angle"][1])), 'XYZ')

                #NyanLi https://github.com/NyaNLI helped a lot to figure out how to convert Minecraft FOV to Blender's FOV
                #fov*1.1 because of specator mode and dynamic fov
                obj_camera.data.lens =  0.5/(math.tan(1.1*math.radians(frameData["angle"][0])/2)) * obj_camera.data.sensor_height

                obj_camera.keyframe_insert(data_path="location", frame=blenderFrame+frameOffset)
                obj_camera.keyframe_insert(data_path="delta_rotation_euler", frame=blenderFrame+frameOffset)
                obj_camera.keyframe_insert(data_path="rotation_euler", frame=blenderFrame+frameOffset)
                obj_camera.data.keyframe_insert(data_path="lens", frame=blenderFrame+frameOffset)

            if "entities" in data:
                entities = data["entities"]
                keyset = entities.keys()

                for entityKey in keyset:
                    entity = entities[entityKey]
                    bpy.ops.object.armature_add()
                    obj = bpy.context.active_object
                
                    obj.name = entityKey

                    for frame in range(len(entity)):

                        blenderFrame = frame

                        if ignoreFrame != -1:
                            if int(frame)%int(ignoreFrame) != 0:
                                continue
                            blenderFrame = int(int(frame) // ignoreFrame)

                        frameData = entity[frame]

                        if "body_rotation" in frameData:
                            obj.delta_rotation_euler  = Euler((math.radians(90-frameData["body_rotation"][2]), 0, math.radians(-frameData["body_rotation"][1])), 'XYZ')
                            obj.keyframe_insert(data_path="delta_rotation_euler", frame=blenderFrame+frameOffset)

                        obj.location = (frameData["position"][0], -frameData["position"][2], frameData["position"][1])
                        obj.keyframe_insert(data_path="location", frame=blenderFrame+frameOffset)

        except:
            traceback.print_exc()
            self.report({"WARNING"}, "An error occured while reading the file.")
            file.close()
            return {"CANCELLED"}
        
        file.close()
        return{'FINISHED'}

# Register and stuff
def menu_func_export(self, context):
    self.layout.operator(ImportJSON.bl_idname, text="JSON cameradata (.json)")

classes = (
    ImportJSON, 
)

def register():
    from bpy.utils import register_class
    for cls in classes:
        register_class(cls)

    bpy.types.TOPBAR_MT_file_import.append(menu_func_export)

def unregister():
    from bpy.utils import unregister_class
    for cls in reversed(classes):
        unregister_class(cls)

    bpy.types.TOPBAR_MT_file_import.remove(menu_func_export)
