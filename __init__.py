bl_info = {
    "name": "Aperture JSON tracking import",
    "author": "Christian F. (known as Chryfi)",
    "version": (1, 2),
    "blender": (2, 80, 0),
    "location": "File > Import",
    "description": "Import tracking data from a json file generated by the Aperture Mod.",
    "warning": "",
    "category": "Import"
}
version_no = 120

import bpy
import json
import math
from math import sqrt
import traceback
import sys
import os
import numpy

from mathutils import Euler
from bpy.props import (BoolProperty, IntProperty, StringProperty)
from bpy_extras.io_utils import (ImportHelper, path_reference_mode)

class ImportJSON(bpy.types.Operator, ImportHelper):
    # Panel's information
    bl_idname = "test.open_filbrowser"
    bl_label = 'Import Aperture JSON'
    bl_options = {'PRESET'}

    # Panel's properties
    filename_ext = ".json"
    filter_glob = StringProperty(default="*.json", options={'HIDDEN'})
    use_selection = BoolProperty(name="Selection only", description="Import selected json only", default=False)
    path_mode = path_reference_mode
    check_extension = True
    frameOffsetPanel: IntProperty(name="Frame offset", default=1)
    cameraImport: BoolProperty(name="Import Camera", default=True)
    entityImport: BoolProperty(name="Import Entities", default=True)
    morphImport: BoolProperty(name="Import Morph-trackers", default=True)

    def execute(self, context):
        file = open(self.properties.filepath,)
        data = json.load(file)
        obj_camera = bpy.context.scene.camera
        frameOffset = self.properties.frameOffsetPanel
        ignoreFrame = -1
        dynamicFOV = True
        positionOffsetX = 0 #seems as if the x coordinate needs to be 0.05 off
        positionOffsetY = 0
        positionOffsetZ = 0
        cameraIndex = "camera_tracking"
        entityIndex = "entity_tracking"
        morphIndex = "morph_tracking"

        if obj_camera is None:
            self.report({"WARNING"}, "No active camera found in the scene.")
            file.close()
            return {"CANCELLED"}

        try:
            if "information" in data:
                try:
                    renderInfo = data["information"]
                    bpy.context.scene.render.fps = renderInfo["fps"]
                    bpy.context.scene.render.resolution_x = renderInfo["resolution"][0]
                    bpy.context.scene.render.resolution_y = renderInfo["resolution"][1]
                    ignoreFrame = round(renderInfo["motionblur_fps"]) / bpy.context.scene.render.fps 
                    dynamicFOV = renderInfo["dynamic_fov"]

                    if version_no<renderInfo["required_import_version"]:
                        self.report({"WARNING"}, "The version of the import script is not compatible with the data! Update the script at https://github.com/Chryfi/io_import_aperture_tracking/releases")
                        file.close()
                        return {"CANCELLED"}
                except:
                    print("Something went wrong while reading the information data!")
                    traceback.print_exc()
            
            obj_camera.delta_location = (positionOffsetX, positionOffsetY, positionOffsetZ)
            obj_camera.rotation_mode = 'XYZ'
            obj_camera.data.sensor_fit = 'VERTICAL'

            #camera tracking
            if self.properties.cameraImport is True:
                for frame in range(len(data[cameraIndex])):
                
                    blenderFrame = frame

                    if ignoreFrame != -1:
                        igFrame = ignoreFrameMath(ignoreFrame, frame)
                            
                        if igFrame == "continue":
                            continue
                            
                        blenderFrame = igFrame

                    frameData = data[cameraIndex][frame]
            
                    obj_camera.location = (frameData["position"][0], -frameData["position"][2], frameData["position"][1])
                    obj_camera.delta_rotation_euler  = Euler((math.radians(90-frameData["angle"][3]), 0, math.radians(-frameData["angle"][2]-180)), 'XYZ')
                    obj_camera.rotation_euler = Euler((0, 0, -math.radians(frameData["angle"][1])), 'XYZ')

                    #NyanLi https://github.com/NyaNLI helped a lot to figure out how to convert Minecraft FOV to Blender's FOV
                    fovFactor = 1.1 if dynamicFOV else 1 #fov*1.1 because of specator mode and dynamic fov - ignores whether other fov effects take place

                    obj_camera.data.lens =  0.5/(math.tan(fovFactor*math.radians(frameData["angle"][0])/2)) * obj_camera.data.sensor_height

                    obj_camera.keyframe_insert(data_path="location", frame=blenderFrame+frameOffset)
                    obj_camera.keyframe_insert(data_path="delta_rotation_euler", frame=blenderFrame+frameOffset)
                    obj_camera.keyframe_insert(data_path="rotation_euler", frame=blenderFrame+frameOffset)
                    obj_camera.data.keyframe_insert(data_path="lens", frame=blenderFrame+frameOffset)


            #entity tracking
            if entityIndex in data and self.properties.entityImport is True:
                entities = data[entityIndex]
                keyset = entities.keys()

                for entityKey in keyset:
                    entity = entities[entityKey]
                    bpy.ops.object.armature_add()
                    obj = bpy.context.active_object
                    obj.name = entityKey

                    for frame in range(len(entity)):
                        blenderFrame = frame

                        if ignoreFrame != -1:
                            igFrame = ignoreFrameMath(ignoreFrame, frame)
                            
                            if igFrame == "continue":
                                continue

                            blenderFrame = igFrame

                        frameData = entity[frame]

                        if "body_rotation" in frameData:
                            obj.delta_rotation_euler  = Euler((math.radians(90-frameData["body_rotation"][2]), 0, math.radians(-frameData["body_rotation"][1])), 'XYZ')
                            obj.keyframe_insert(data_path="delta_rotation_euler", frame=blenderFrame+frameOffset)

                        obj.location = (frameData["position"][0], -frameData["position"][2], frameData["position"][1])
                        obj.keyframe_insert(data_path="location", frame=blenderFrame+frameOffset)
            

            #morph tracking
            if self.properties.morphImport is True:
                morphs = data[morphIndex]
                keyset = morphs.keys()

                for morphKey in keyset:
                    morph = morphs[morphKey]

                    bpy.ops.object.armature_add()

                    obj = bpy.context.active_object
                    obj.name = morphKey
                    startFrame = 0

                    for frame in range(len(morph)):
                        blenderFrame = frame

                        if ignoreFrame != -1:
                            igFrame = ignoreFrameMath(ignoreFrame, frame)
                            
                            if igFrame == "continue":
                                continue

                            blenderFrame = igFrame
                        
                        frameData = morph[frame]

                        if frame == 0:
                            startFrame = int(int(frameData["frame"]) // ignoreFrame)

                        #obj.delta_rotation_euler = Euler((math.radians(90), 0, 0), 'ZXY')
                        #obj.rotation_euler = Euler((math.radians(frameData["rotation"][1]), math.radians(frameData["rotation"][0] - 90), math.radians(90 - frameData["rotation"][2])), 'ZXY')
                        
                        obj.rotation_mode = 'ZYX'
                        obj.rotation_euler = (math.radians(frameData["rotation"][0]+90), math.radians(frameData["rotation"][1]), math.radians(frameData["rotation"][2]))
                        obj.location = (frameData["position"][0], -frameData["position"][2], frameData["position"][1])

                        obj.keyframe_insert(data_path="rotation_euler", frame=blenderFrame+frameOffset+startFrame)
                        obj.keyframe_insert(data_path="location", frame=blenderFrame+frameOffset+startFrame)
        
        except:
            traceback.print_exc()
            self.report({"WARNING"}, "An error occured while reading the file.")
            file.close()
            return {"CANCELLED"}
        
        file.close()
        return{'FINISHED'}

    def draw(self, context):
        layout = self.layout
        layout.use_property_split = True
        layout.use_property_decorate = False

        sfile = context.space_data
        operator = sfile.active_operator

        layout.prop(operator, 'frameOffsetPanel')
        layout.prop(operator, 'cameraImport')
        layout.prop(operator, 'entityImport')
        layout.prop(operator, 'morphImport')

def ignoreFrameMath(ignoreFrame : int, frame : int):
    if int(frame)%int(ignoreFrame) != 0:
        return "continue"
    return int(int(frame) // ignoreFrame)

# Register and stuff
def menu_func_import(self, context):
    self.layout.operator(ImportJSON.bl_idname, text="JSON cameradata (.json)")

classes = (
    ImportJSON, 
)

def register():
    from bpy.utils import register_class
    for cls in classes:
        register_class(cls)

    bpy.types.TOPBAR_MT_file_import.append(menu_func_import)

def unregister():
    from bpy.utils import unregister_class
    for cls in reversed(classes):
        unregister_class(cls)

    bpy.types.TOPBAR_MT_file_import.remove(menu_func_import)
