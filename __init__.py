bl_info = {
    "name": "Aperture JSON cameradata import",
    "author": "Christian F. (known as Chryfi)",
    "version": (0, 9, 0),
    "blender": (2, 80, 0),
    "location": "File > Import",
    "description": "Import camera movement from a json file generated by the aperture mod.",
    "warning": "",
    "category": "Import"
}

import bpy
import json
import math
from math import sqrt
import traceback
import sys
import os
import numpy

from mathutils import Euler
from bpy.props import (BoolProperty, StringProperty)
from bpy_extras.io_utils import (ImportHelper, path_reference_mode)

def cubic_interp(x0, x, y):
    """
    Interpolate a 1-D function using cubic splines.
      x0 : a 1d-array of floats to interpolate at
      x : a 1-D array of floats sorted in increasing order
      y : A 1-D array of floats. The length of y along the
          interpolation axis must be equal to the length of x.

    Implement a trick to generate at first step the cholesky matrice L of
    the tridiagonal matrice A (thus L is a bidiagonal matrice that
    can be solved in two distinct loops).

    additional ref: www.math.uh.edu/~jingqiu/math4364/spline.pdf 
    # original function code at: https://stackoverflow.com/a/48085583/36061
    
    
    This function is licenced under: Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)
    https://creativecommons.org/licenses/by-sa/3.0/
    Original Author raphael valentin
    Date 3 Jan 2018
    
    
    Modifications made to remove numpy dependencies:
        -all sub-functions by MR
        
    This function, and all sub-functions, are licenced under: Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)        
        
    Mod author: Matthew Rowles
    Date 3 May 2021
    
    """
    def diff(lst):
        """
        numpy.diff with default settings
        """
        size = len(lst)-1
        r = [0]*size
        for i in range(size):
            r[i] = lst[i+1] - lst[i] 
        return r
    
    def list_searchsorted(listToInsert, insertInto):
        """
        numpy.searchsorted with default settings
        """
        def float_searchsorted(floatToInsert, insertInto):
            for i in range(len(insertInto)):
                if floatToInsert <= insertInto[i]:
                    return i
            return len(insertInto)
        return [float_searchsorted(i, insertInto) for i in listToInsert]
    
    def clip(lst, min_val, max_val, inPlace = False):    
        """
        numpy.clip
        """
        if not inPlace:
            lst = lst[:]  
        for i in range(len(lst)):
            if lst[i] < min_val:
                lst[i] = min_val
            elif lst[i] > max_val:
                lst[i] = max_val  
        return lst
    
    def subtract(a,b):
        """
        returns a - b
        """
        return a - b
    
    size = len(x)

    xdiff = diff(x)
    ydiff = diff(y)

    # allocate buffer matrices
    Li   = [0]*size
    Li_1 = [0]*(size-1)
    z    = [0]*(size)

    # fill diagonals Li and Li-1 and solve [L][y] = [B]
    Li[0]   = sqrt(2*xdiff[0])
    Li_1[0] = 0.0
    B0      = 0.0 # natural boundary
    z[0]    = B0 / Li[0]

    for i in range(1, size-1, 1):
        Li_1[i] = xdiff[i-1] / Li[i-1]
        Li[i] = sqrt(2*(xdiff[i-1]+xdiff[i]) - Li_1[i-1] * Li_1[i-1])
        Bi = 6*(ydiff[i]/xdiff[i] - ydiff[i-1]/xdiff[i-1])
        z[i] = (Bi - Li_1[i-1]*z[i-1])/Li[i]

    i = size - 1
    Li_1[i-1] = xdiff[-1] / Li[i-1]
    Li[i]     = sqrt(2*xdiff[-1] - Li_1[i-1] * Li_1[i-1])
    Bi        = 0.0 # natural boundary
    z[i]      = (Bi - Li_1[i-1]*z[i-1])/Li[i]

    # solve [L.T][x] = [y]
    i = size-1
    z[i] = z[i] / Li[i]
    for i in range(size-2, -1, -1):
        z[i] = (z[i] - Li_1[i-1]*z[i+1])/Li[i]

    # find index
    index = list_searchsorted(x0,x)
    index = clip(index, 1, size-1)

    xi1 = [x[num]   for num in index]
    xi0 = [x[num-1] for num in index]
    yi1 = [y[num]   for num in index]
    yi0 = [y[num-1] for num in index]
    zi1 = [z[num]   for num in index]
    zi0 = [z[num-1] for num in index]
    hi1 = list( map(subtract, xi1, xi0) )

    # calculate cubic - all element-wise multiplication
    f0 = [0]*len(hi1)
    for j in range(len(f0)):
        f0[j] = zi0[j]/(6*hi1[j])*(xi1[j]-x0[j])**3 + \
                zi1[j]/(6*hi1[j])*(x0[j]-xi0[j])**3 + \
                (yi1[j]/hi1[j] - zi1[j]*hi1[j]/6)*(x0[j]-xi0[j]) + \
                (yi0[j]/hi1[j] - zi0[j]*hi1[j]/6)*(xi1[j]-x0[j])        
    
    return f0

class ImportJSON(bpy.types.Operator, ImportHelper):
    # Panel's information
    bl_idname = "test.open_filbrowser"
    bl_label = 'Import Aperture JSON'
    bl_options = {'PRESET'}

    # Panel's properties
    filename_ext = ".json"
    filter_glob = StringProperty(default="*.json", options={'HIDDEN'})
    use_selection = BoolProperty(name="Selection only", description="Import selected json only", default=False)
    path_mode = path_reference_mode
    check_extension = True

    def execute(self, context):
        file = open(self.properties.filepath,)
        data = json.load(file)
        obj_camera = bpy.context.scene.camera
        frameOffset = 1 #first frame of minema rendered video are not usable.
        coordinateCorrectionY = 0 #seems as if the y coordinate needs to be -0.04 off

        if obj_camera is None:
            self.report({"WARNING"}, "No active camera found in the scene.")
            file.close()
            return {"CANCELLED"}

        try:
            if "information" in data:
                renderInfo = data["information"]
                bpy.context.scene.render.fps = renderInfo["fps"]
                bpy.context.scene.render.resolution_x = renderInfo["resolution"][0]
                bpy.context.scene.render.resolution_y = renderInfo["resolution"][1]
                
                if renderInfo["held_frames"] > 1:
                    frameOffset = 1
            
            obj_camera.delta_location = (0, coordinateCorrectionY, 0)

            #possible interpolated functions for FOV dataset https://docs.google.com/spreadsheets/d/1WJVoWsvNT1AA2BxMRuZtXw0CxF1kkeuByHMhyBgvIy8/edit?usp=sharing
            # 0.302458 + 1.99536 x - 0.00622598 x^2
            x_points = [ 2.5,     5,     10,    20,   25,    30, 35,    40,     50,    60,   70,      80,   90,  100,  110,    120,  130,  140]
            y_points = [ 411,   211, 105.25, 52.15, 41.4, 34.25, 29, 25.20, 19.525, 15.63, 12.75, 10.525, 8.68, 7.125, 5.71, 4.535, 3.41, 2.35]

            for frame in range(len(data["camera-tracking"])):
                frameData = data["camera-tracking"][frame]
            
                obj_camera.location = (frameData["position"][0], -frameData["position"][2], frameData["position"][1])
                obj_camera.delta_rotation_euler  = Euler((math.radians(90-frameData["angle"][3]), 0, math.radians(-frameData["angle"][2]-180)), 'XYZ')
                obj_camera.rotation_euler = Euler((0, 0, -math.radians(frameData["angle"][1])), 'XYZ')
                obj_camera.data.lens = cubic_interp([frameData["angle"][0]], x_points, y_points)[0]

                obj_camera.keyframe_insert(data_path="location", frame=frame+frameOffset)
                obj_camera.keyframe_insert(data_path="delta_rotation_euler", frame=frame+frameOffset)
                obj_camera.keyframe_insert(data_path="rotation_euler", frame=frame+frameOffset)
                obj_camera.data.keyframe_insert(data_path="lens", frame=frame+frameOffset)

            if "entities" in data:
                entities = data["entities"]
                keyset = entities.keys()

                for entityKey in keyset:
                    entity = entities[entityKey]
                    bpy.ops.object.armature_add()
                    obj = bpy.context.active_object
                
                    obj.name = entityKey

                    for frame in range(len(entity)):
                        frameData = entity[frame]

                        if "body_rotation" in frameData:
                            obj.delta_rotation_euler  = Euler((math.radians(90-frameData["body_rotation"][2]), 0, math.radians(-frameData["body_rotation"][1])), 'XYZ')
                            obj.keyframe_insert(data_path="delta_rotation_euler", frame=frame+frameOffset)

                        obj.location = (frameData["position"][0], -frameData["position"][2], frameData["position"][1])
                        obj.keyframe_insert(data_path="location", frame=frame+frameOffset)

        except:
            traceback.print_exc()
            self.report({"WARNING"}, "An error occured while reading the file.")
            file.close()
            return {"CANCELLED"}
        
        file.close()
        return{'FINISHED'}

# Register and stuff
def menu_func_export(self, context):
    self.layout.operator(ImportJSON.bl_idname, text="JSON cameradata (.json)")

classes = (
    ImportJSON, 
)

def register():
    from bpy.utils import register_class
    for cls in classes:
        register_class(cls)

    bpy.types.TOPBAR_MT_file_import.append(menu_func_export)

def unregister():
    from bpy.utils import unregister_class
    for cls in reversed(classes):
        unregister_class(cls)

    bpy.types.TOPBAR_MT_file_import.remove(menu_func_export)

"""def convertMinecraftFOVinterpolation(x):
    x_points = [   140,     130,  120,  110,  100,  90,    80,   70,   60,    50,    40,    30,    20,    10,     5, 2.5]
    y_points = [ 2.325,  3.3825, 4.44, 5.65, 7.02, 8.5, 10.35, 12.5, 15.3, 19.05, 24.55, 33.55, 50.65, 102.4, 205.2, 411]

    tck = interpolate.splrep(x_points, y_points)
    return interpolate.splev(x, tck)"""
